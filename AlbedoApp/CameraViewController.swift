//
//  CameraViewController.swift
//  AlbedoApp
//
//  Created by crt2004 on 12/22/17.
//
//  ----- Adapted from: -----
//
//  Apple's Photo Capture Guide
//  https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/PhotoCaptureGuide/index.html
//
//  Apple's Sample Camera App - AVCamManual
//  https://developer.apple.com/library/content/samplecode/AVCamManual/Introduction/Intro.html
//
//  Apple's CoreMotion Demo App - MotionGraphs
//  https://developer.apple.com/library/content/samplecode/MotionGraphs/Introduction/Intro.html
//

import UIKit
import AVFoundation
import CoreMotion

class CameraViewController: UIViewController {
    
    // Camera and UI properties
    //let cameraController = CameraController()
    @IBOutlet fileprivate var capturePreviewView: CameraPreviewView! // Displays a preview of the video output generated by the device's cameras.
    var sessionQueue: DispatchQueue!
    var isSessionRunning: Bool = false
    private var setupResult: CameraSetupResult = .success
    var videoDeviceDiscoverySession: AVCaptureDeviceDiscoverySession?
    var captureSession: AVCaptureSession?
    var photoOutput: AVCapturePhotoOutput?
    var rearCamera: AVCaptureDevice?
    var rearCameraInput: AVCaptureDeviceInput?
    private var inProgressPhotoCaptureDelegates: [Int64: AlbedoPhotoCaptureDelegateType] = [:]
    
    // MotionGraphContainer properties
    let motionManager = CMMotionManager() // motion manager object
    let levelingThreshold = 1.5 // within how many degrees the device must be in order to count as level
    let updateInterval = 0.02 // measured in seconds
    
    var circularLevel:CircularLevel! // create a circular level object
    
    override var prefersStatusBarHidden: Bool { return true }
    
    // MARK: UIViewController overrides
    override func viewDidLoad() {
        
        // add the circular level to the view
        circularLevel = CircularLevel(frame: UIScreen.main.bounds) // create a new Circular Level object
        self.view.addSubview(circularLevel) // add it to the view
        
        // camera setup
        self.captureSession = AVCaptureSession()
        let deviceTypes: [AVCaptureDevice.DeviceType] = [AVCaptureDevice.DeviceType.builtInWideAngleCamera, AVCaptureDevice.DeviceType.builtInDualCamera, AVCaptureDevice.DeviceType.builtInTelephotoCamera]
        self.videoDeviceDiscoverySession = AVCaptureDevice.DiscoverySession(deviceTypes: deviceTypes, mediaType: AVMediaTypeVideo, position: .unspecified)
        
        // Setup the preview view.
        self.capturePreviewView.session = self.captureSession
        self.capturePreviewView.previewLayer.videoGravity = AVLayerVideoGravityResizeAspectFill
        
        // Communicate with the session and other session objects on this queue.
        self.sessionQueue = DispatchQueue(label: "session queue", attributes: [])
        
        self.setupResult = .success
        
        // Check video authorization status. Video access is required and audio access is optional.
        // If audio access is denied, audio is not recorded during movie recording.
        switch AVCaptureDevice.authorizationStatus(forMediaType: AVMediaTypeVideo) {
        case .authorized:
            // The user has previously granted access to the camera.
            break
        case .notDetermined:
            // The user has not yet been presented with the option to grant video access.
            // We suspend the session queue to delay session running until the access request has completed.
            // Note that audio access will be implicitly requested when we create an AVCaptureDeviceInput for audio during session setup.
            self.sessionQueue.suspend()
            AVCaptureDevice.requestAccess(forMediaType: AVMediaTypeVideo) {granted in
                if !granted {
                    self.setupResult = .cameraNotAuthorized
                }
                self.sessionQueue.resume()
            }
        default:
            // The user has previously denied access.
            self.setupResult = .cameraNotAuthorized
        }
        
        self.sessionQueue.async {
            self.configureSession()
        }
        
        
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        
        // start the device motion updates
        startMotionUpdates()
        
        // setup camera
        self.sessionQueue.async {
            switch self.setupResult {
            case .success:
                // Only setup observers and start the session running if setup succeeded.
                //self.addObservers() ------------------------------------------------------------------------------------------------------------------------------------ <-- add observers?
                self.captureSession?.startRunning()
                self.isSessionRunning = (self.captureSession?.isRunning)!
            case .cameraNotAuthorized:
                DispatchQueue.main.async {
                    let message = NSLocalizedString("Albedo App requires access to the camera in order to take images needed to calculate albedo.", comment: "Needs camera permission")
                    let alertController = UIAlertController(title: "AVCamManual", message: message, preferredStyle: .alert)
                    let cancelAction = UIAlertAction(title: NSLocalizedString("OK", comment: "Alert OK button"), style: .cancel, handler: nil)
                    alertController.addAction(cancelAction)
                    // Provide quick access to Settings.nil
                    let settingsAction = UIAlertAction(title: NSLocalizedString("Settings", comment: "Alert button to open Settings"), style: .default) {action in
                        if #available(iOS 10.0, *) {
                            UIApplication.shared.open(URL(string: UIApplicationOpenSettingsURLString)!)
                        } else {
                            UIApplication.shared.openURL(URL(string: UIApplicationOpenSettingsURLString)!)
                        }
                    }
                    alertController.addAction(settingsAction)
                    self.present(alertController, animated: true, completion: nil)
                }
            case .sessionConfigurationFailed:
                DispatchQueue.main.async {
                    let message = NSLocalizedString("Unable to capture media", comment: "Alert if capture session configuration error")
                    let alertController = UIAlertController(title: "Albedo App", message: message, preferredStyle: .alert)
                    let cancelAction = UIAlertAction(title: NSLocalizedString("OK", comment: "Alert OK button"), style: .cancel, handler: nil)
                    alertController.addAction(cancelAction)
                    self.present(alertController, animated: true, completion: nil)
                }
            }
        }
    }
    
    override func viewDidDisappear(_ animated: Bool) {
        stopMotionUpdates()
        self.sessionQueue.async {
            if self.setupResult == .success {
                self.captureSession?.stopRunning()
                // self.removeObservers()
            }
        }
        super.viewDidDisappear(animated)
    }
    
    func configureSession() {
        guard self.setupResult == .success else {
            return
        }
        
        self.captureSession?.beginConfiguration()
        
        self.captureSession?.sessionPreset = AVCaptureSessionPresetPhoto
        
        // Add video input
        let videoDevice: AVCaptureDevice!
        videoDevice = AVCaptureDevice.defaultDevice(withDeviceType: AVCaptureDevice.DeviceType.builtInWideAngleCamera, mediaType:AVMediaTypeVideo, position: .unspecified)
        let videoDeviceInput: AVCaptureDeviceInput
        do {
            videoDeviceInput = try AVCaptureDeviceInput(device:videoDevice)
        } catch {
            NSLog("Could not create video device input: \(error)")
            self.setupResult = .sessionConfigurationFailed
            self.captureSession?.commitConfiguration()
            return
        }
        
        if (self.captureSession?.canAddInput(videoDeviceInput))! {
            self.captureSession?.addInput(videoDeviceInput)
            self.rearCameraInput = videoDeviceInput
            self.rearCamera = videoDevice
            
            DispatchQueue.main.async {
                /*
                 Why are we dispatching this to the main queue?
                 Because AVCaptureVideoPreviewLayer is the backing layer for AVCamManualPreviewView and UIView
                 can only be manipulated on the main thread.
                 Note: As an exception to the above rule, it is not necessary to serialize video orientation changes
                 on the AVCaptureVideoPreviewLayerâ€™s connection with other session manipulation.
                 
                 Use the status bar orientation as the initial video orientation. Subsequent orientation changes are
                 handled by -[AVCamManualCameraViewController viewWillTransitionToSize:withTransitionCoordinator:].
                 */
                let statusBarOrientation = UIApplication.shared.statusBarOrientation
                var initialVideoOrientation = AVCaptureVideoOrientation.portrait
                if statusBarOrientation != UIInterfaceOrientation.unknown {
                    initialVideoOrientation = AVCaptureVideoOrientation(rawValue: statusBarOrientation.rawValue)!
                }
                
                let previewLayer = self.capturePreviewView.layer as! AVCaptureVideoPreviewLayer
                previewLayer.connection?.videoOrientation = initialVideoOrientation
                
            }
        } else {
            NSLog("Could not add video device input to the session")
            self.setupResult = .sessionConfigurationFailed
            self.captureSession?.commitConfiguration()
            return
        }
        
        // Add photo output
        let photoOutput = AVCapturePhotoOutput()
        if (self.captureSession?.canAddOutput(photoOutput))! {
            self.captureSession?.addOutput(photoOutput)
            self.photoOutput = photoOutput
            photoOutput.isHighResolutionCaptureEnabled = true
            
            self.inProgressPhotoCaptureDelegates = [:]
        } else {
            NSLog("Could not add photo output to the session")
            self.setupResult = .sessionConfigurationFailed
            self.captureSession?.commitConfiguration()
            return
        }
        
        self.captureSession?.commitConfiguration()
    }
    
    private func captureImage() {
        //let previewLayer = self.capturePreviewView.layer as! AVCaptureVideoPreviewLayer
        //let videoPreviewLayerVideoOrientation = previewLayer.connection?.videoOrientation
        
        guard let availableRawFormat = photoOutput?.availableRawPhotoPixelFormatTypes[0] else { print("ERROR - There are no raw formats available"); return }
        let settings = AVCapturePhotoSettings(rawPixelFormatType: availableRawFormat.uint32Value)
        
        /*if !(photoOutput?.availableRawPhotoPixelFormatTypes.isEmpty)! { //availableRawPhotoFileTypes
            settings = AVCapturePhotoSettings(rawPixelFormatType: (photoOutput?.availableRawPhotoPixelFormatTypes[0].uint32Value)!, processedFormat: [AVVideoCodecKey : AVVideoCodecJPEG])
        } else {
            print("ERROR - no raw format types available")
        }*/
        
        self.sessionQueue.async {
            let photoCaptureDelegate = AlbedoPhotoCaptureDelegate(requestedPhotoSettings: settings, willCapturePhotoAnimation: {
                // Perform a shutter animation.
                DispatchQueue.main.async {
                    self.capturePreviewView.layer.opacity = 0.0
                    UIView.animate(withDuration: 0.25) {
                        self.capturePreviewView.layer.opacity = 1.0
                    }
                }
            }, completed: {photoCaptureDelegate in
                // When the capture is complete, remove a reference to the photo capture delegate so it can be deallocated.
                self.sessionQueue.async {
                    self.inProgressPhotoCaptureDelegates[photoCaptureDelegate.requestedPhotoSettings.uniqueID] = nil
                }
            })
            
            /*
             The Photo Output keeps a weak reference to the photo capture delegate so
             we store it in an array to maintain a strong reference to this object
             until the capture is completed.
             */
            self.inProgressPhotoCaptureDelegates[photoCaptureDelegate.requestedPhotoSettings.uniqueID] = photoCaptureDelegate
            self.photoOutput?.capturePhoto(with: settings, delegate: photoCaptureDelegate)
        }
        
        stopMotionUpdates()
    }
    
    // MARK: MotionGraphContainer implementation
    
    // start updates for leveling data. Captures image when roll, pitch, and yaw meet the established
    // threshold set by the property levelingThreshold
    func startMotionUpdates() {
        if !motionManager.isDeviceMotionAvailable {
            print("ERROR - dev motion not available");
            return
        }
        motionManager.deviceMotionUpdateInterval = self.updateInterval
        
        motionManager.startDeviceMotionUpdates(to: .main) { deviceMotion, error in
            guard let deviceMotion = deviceMotion else { return }

            self.circularLevel.getPoint(attitude: deviceMotion.attitude)
            
            let roll = deviceMotion.attitude.roll * (180 / Double.pi) // get roll, convert from radians to degrees
            let pitch = deviceMotion.attitude.pitch * (180 / Double.pi) // get pitch, convert from radians to degrees
            let yaw = deviceMotion.attitude.yaw * (180 / Double.pi) // get yaw, convert from radians to degrees
            let thresh = self.levelingThreshold
            
            // ensure that roll, pitch, and yaw are all within the threshold to take a picture
            if abs(roll) <= thresh && abs(pitch) <= thresh && abs(yaw) <= thresh {
                print("*** Device is level - capturing image - roll:\(roll) pitch:\(pitch) yaw:\(yaw)")
                self.captureImage()
            } else {
                print("Device not level: roll:\(roll) pitch:\(pitch) yaw:\(yaw)")
            }
        }
    }
    
    // stop the leveling data updates
    func stopMotionUpdates() {
        if !motionManager.isDeviceMotionActive { return }
        motionManager.stopDeviceMotionUpdates()
    }
}

private enum CameraSetupResult: Int {
    case success
    case cameraNotAuthorized
    case sessionConfigurationFailed
}
